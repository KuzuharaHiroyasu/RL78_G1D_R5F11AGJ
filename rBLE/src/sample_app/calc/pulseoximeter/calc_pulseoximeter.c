/************************************************************************/
/* システム名   : RD8001快眠チェッカー									*/
/* ファイル名   : calc_pulseoximeter.c									*/
/* 機能         : パルスオキシメーター演算処理							*/
/* 変更履歴     : 2018.01.11 Axia Soft Design 和田 初版作成				*/
/* 注意事項     : なし													*/
/************************************************************************/
#include <math.h>
#include "calc_pulseoximeter.h"
#include "pulse_param.h"
#include "../calc_data.h"
#include "../libfft/r_fft_int16.h"		// FFTライブラリ

/************************************************************/
/* プロトタイプ宣言											*/
/************************************************************/
static	void	proc(const double *data1, int len, int* psnpk, double* pmk);
extern	int		peak_modify	( double in_data[] , H in_res[] , double ot_data[] , double ot_hz[] , int size , double delta );	/* ☆ */
extern	void 	peak_vallay	( double in[] , H ot[] , int size, int width , double th , int peak );
extern	void	cal_sp1		( double mx1 , double mx2 , int *sp );
extern	void	ifft(double ar[] ,int N ,double ot[]);

/************************************************************/
/* 定数定義													*/
/************************************************************/
// FFTに与える窓のデータ ハニング関数
static const int16_t window_data[DATA_SIZE_SPO2] = {
2621.44	,
2639.595355	,
2694.017685	,
2784.57589	,
2911.05182	,
3073.140801	,
3270.45237	,
3502.511213	,
3768.758314	,
4068.552299	,
4401.170979	,
4765.813094	,
5161.600242	,
5587.578992	,
6042.723186	,
6525.936405	,
7036.054615	,
7571.848969	,
8132.028769	,
8715.24457	,
9320.091439	,
9945.112331	,
10588.80161	,
11249.60865	,
11925.94162	,
12616.17126	,
13318.63485	,
14031.64019	,
14753.46968	,
15482.38449	,
16216.6287	,
16954.43355	,
17694.0217	,
18433.61154	,
19171.42143	,
19905.67403	,
20634.60056	,
21356.44507	,
22069.46869	,
22771.95378	,
23462.20809	,
24138.56883	,
24799.4067	,
25443.12976	,
26068.18732	,
26673.07366	,
27256.33163	,
27816.5562	,
28352.39782	,
28862.56567	,
29345.8308	,
29801.02903	,
30227.06382	,
30622.90888	,
30987.61063	,
31320.29054	,
31620.14719	,
31886.45824	,
32118.58217	,
32315.9598	,
32478.11566	,
32604.65913	,
32695.28536	,
32749.77605	,
32767,
32749.91311	,
32695.55914	,
32605.06896	,
32478.66057	,
32316.63847	,
32119.39297	,
31887.39921	,
31621.21606	,
31321.48475	,
30988.9273	,
30624.34482	,
30228.61559	,
29802.69288	,
29347.60273	,
28864.44142	,
28354.37286	,
27818.62577	,
27258.49075	,
26675.31712	,
26070.50973	,
25445.52551	,
24801.87003	,
24141.09381	,
23464.78862	,
22774.58366	,
22072.14157	,
21359.15452	,
20637.34005	,
19908.43697	,
19174.20116	,
18436.40136	,
17696.81489	,
16957.22338	,
16219.40845	,
15485.14747	,
14756.20923	,
14034.3497	,
13321.30781	,
12618.80122	,
11928.52225	,
11252.13373	,
10591.26506	,
9947.508217	,
9322.413988	,
8717.488187	,
8134.188049	,
7573.918712	,
7038.029834	,
6527.812341	,
6044.495321	,
5589.243057	,
5163.152228	,
4767.249263	,
4402.487871	,
4069.746741	,
3769.82743	,
3503.452427	,
3271.263413	,
3073.819721	,
2911.596982	,
2784.98598	,
2694.291715	,
2639.732665	,
};

/************************************************************/
/* 変数定義													*/
/************************************************************/
static double	mx1_;
static double	mx2_;
static int	snpk1_;
static int	snpk2_;
static int		sp1_;

/*------------------------------------------------------------------------------*/

/********************************************************************/
/* 関数     : calculator_pulse_oximeter_red							*/
/* 関数名   : パルスオキシメーター演算[赤色]						*/
/* 引数     : なし													*/
/* 戻り値   : なし													*/
/* 変更履歴 : 2018.01.11 Axia Soft Design 和田	初版作成			*/
/********************************************************************/
/* 機能 :															*/
/* 																	*/
/********************************************************************/
/* 注意事項 :														*/
/* なし																*/
/********************************************************************/
// データ数はFFTライブラリに合わせて128固定
void calculator_pulse_oximeter_red(const signed long* pdata1)
{
	double tmp;
	int i;
	
	for (i=0; i<DATA_SIZE_SPO2; i++)
	{
		tmp = (double)pdata1[i];
		// -3〜3Vの24bit分解能AD値
		temp_dbl_buf2[i] = tmp;
	}
//	proc(test_data, DATA_SIZE_SPO2, &snpk1_, &mx1_);
	proc(temp_dbl_buf2, DATA_SIZE_SPO2, &snpk1_, &mx1_);
	if((0 > snpk1_) || (snpk1_ > 200)){
		snpk1_ = 0;
	}
}

/********************************************************************/
/* 関数     : calculator_pulse_oximeter_inf							*/
/* 関数名   : パルスオキシメーター演算[赤外]						*/
/* 引数     : なし													*/
/* 戻り値   : なし													*/
/* 変更履歴 : 2018.01.11 Axia Soft Design 和田	初版作成			*/
/********************************************************************/
/* 機能 :															*/
/* 																	*/
/********************************************************************/
/* 注意事項 :														*/
/* なし																*/
/********************************************************************/
// データ数はFFTライブラリに合わせて128固定
void calculator_pulse_oximeter_inf(const signed long* pdata1)
{
	double tmp;
	int i;
	
	for (i = 0; i<DATA_SIZE_SPO2; i++)
	{
		tmp = (double)pdata1[i];
		temp_dbl_buf2[i] = tmp;
	}
	proc(temp_dbl_buf2, DATA_SIZE_SPO2, &snpk2_, &mx2_);
	if((0 > snpk2_) || (snpk2_ > 200)){
		snpk2_ = 0xFF;
	}
	
	/*- SPO2 --------------------------------------------------------------*/
	cal_sp1( mx1_, mx2_, &sp1_ );
	if((0 > sp1_) || (sp1_ > 200)){
		sp1_ = 0xFF;
	}
}

/********************************************************************/
/* 関数     : proc													*/
/* 関数名   : 														*/
/* 引数     : なし													*/
/* 戻り値   : なし													*/
/* 変更履歴 : 2018.01.11 Axia Soft Design 和田	初版作成			*/
/********************************************************************/
/* 機能 :															*/
/* 																	*/
/********************************************************************/
/* 注意事項 :														*/
/* len = 128でないと動かない										*/
/********************************************************************/
static void	proc(const double *data1, int len, int* psnpk, double* pmk)
{
	int ii;
	
	double* ph11;
	int16_t* pfft_in;

	int16_t* pfft_out;

	double* a1;
	double* p2;
	double* ar2;
	double* ai2;
	double* p3;
	double*	p4;
	double*	f1;
	int16_t* peak1;
	
	const int loop = len + _PULSE_PARAM_END;
	const int start = _PULSE_PARAM_START;
	const int end   = _PULSE_PARAM_END + start;
	const double coeff = _PULSE_PARAM_SNPK_COEF;
	
	int size;
	double max;
	double min = data1[0];
	
	/*- DC成分除去 -----------------------------------------------------------------*/
	ph11 = &temp_dbl_buf0[0];
	for(ii=1;ii<len;++ii){
		if(min > data1[ii]){
			min = data1[ii];
		}
	}
	for(ii=0;ii<len;++ii){
		ph11[ii] = (data1[ii] - min);
		ph11[ii] *= 0.0001;
	}
	
	/*- fft --------------------------------------------------------------------*/
	pfft_in = &temp_int_buf0[0];
	for(ii=0;ii<len;++ii){
		pfft_in[ii] = (int16_t)(ph11[ii] * 32768.0f);
	}
	pfft_out = &temp_int_buf2[0];
    /* execute 128-point real FFT with windowing */
    R_rfft128_int16(pfft_in, pfft_out, window_data, temp_int_buf1);

	/*- 不要なデータをマスクする------------------------------------------------*/
	/*- パワーを求める----------------------------------------------------------*/
	a1 = &temp_dbl_buf0[0];
	p2 = &temp_dbl_buf1[0];
	for(ii=0;ii<loop;++ii){
		a1[ii] = pfft_out[ii] / 128.0;
	}
	// startまではall 0
	for(ii=0;ii<start;++ii){
		p2[ii] = 0;
	}
	for(ii=start;ii<end;++ii){
		p2[ii] = a1[2*ii]*a1[2*ii] + a1[2*ii+1]*a1[2*ii+1];
		p2[ii] = sqrt(p2[ii]);
	}
	for(ii=end;ii<loop;++ii){
		p2[ii] = 0;
	}
	
	/*- 逆FFT --------------------------------------------------------------*/
	ar2 = &temp_dbl_buf1[0];
	ai2 = &temp_dbl_buf2[0];
	size = loop/2;
	for(ii=0;ii<size;++ii){
		ar2[ii] = p2[ii];
		ai2[ii] = 0;
	}
	for(ii=0;ii<size;++ii){
		ar2[size+ii] = p2[size-ii];
		ai2[size+ii] = 0;
	}
	
	p3 = &temp_dbl_buf0[0];
	ifft(ar2, loop, p3);
	
	/*- 最大値との比を計算 --------------------------------------------------------------*/
	max = 0;
	for(ii=0;ii<len;++ii){
		if(max < p3[ii]){
			max = p3[ii];
		}
	}
	for(ii=0;ii<len;++ii){
		p3[ii] /= max;
	}
	
	/*- ピーク検出 --------------------------------------------------------------*/
	peak1 = &temp_int_buf0[0];
	p4 = &temp_dbl_buf1[0];
	f1 = &temp_dbl_buf2[0];
	peak_vallay( p3 , peak1 , len, 3 , 0.1 , 1 );
	peak_modify( p3 , peak1 , p4 , f1 , len , 1);
	
	/*- HR --------------------------------------------------------------*/
	*psnpk = 60 / (f1[0] * coeff);
	*pmk   = p4[0];
}

// 心拍数(赤色)
UB get_sinpak(void)
{
	return (UB)snpk1_;
}

// SPO2を取得
UB get_spo2(void)
{
	return (UB)sp1_;
}

/*==============================================================================*/
/* EOF */
