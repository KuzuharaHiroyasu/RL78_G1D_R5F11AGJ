/************************************************************************/
/* システム名   : RD8001快眠チェッカー									*/
/* ファイル名   : calc_pulseoximeter.c									*/
/* 機能         : パルスオキシメーター演算処理							*/
/* 変更履歴     : 2018.01.11 Axia Soft Design 和田 初版作成				*/
/* 注意事項     : なし													*/
/************************************************************************/
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "calc_pulseoximeter.h"
#include "../calc_data.h"
#include "../libfft/r_fft_int16.h"		// FFTライブラリ

/************************************************************/
/* プロトタイプ宣言											*/
/************************************************************/
static	void	proc(const double *data1, int len, int* psnpk, double* pmk);
static	void	bandpass(const double input[], double output[], int size, double samplerate, double freq, double bw);

extern	int		peak_modify	( double in_data[] , H in_res[] , double ot_data[] , double ot_hz[] , int size , double delta );	/* ☆ */
extern	void 	peak_vallay	( double in[] , H ot[] , int size, int width , double th , int peak );
extern	void	cal_sp1		( double mx1 , double mx2 , int *sp );
extern	void	ifft(double ar[] ,int N ,double ot[]);

/************************************************************/
/* 定数定義													*/
/************************************************************/
static const double test_data[DATA_SIZE_SPO2] = {
0.771562	,
0.7867	,
0.773816	,
0.755779	,
0.753524	,
0.76061	,
0.787666	,
0.799906	,
0.799906	,
0.795396	,
0.808602	,
0.803127	,
0.798939	,
0.791531	,
0.778326	,
0.777359	,
0.785412	,
0.789599	,
0.77285	,
0.755135	,
0.764153	,
0.788632	,
0.816332	,
0.834692	,
0.850474	,
0.869478	,
0.881395	,
0.878818	,
0.884938	,
0.888159	,
0.892668	,
0.895567	,
0.892346	,
0.870122	,
0.83598	,
0.819231	,
0.824063	,
0.831471	,
0.839523	,
0.839523	,
0.835014	,
0.838235	,
0.838557	,
0.845321	,
0.849508	,
0.848219	,
0.850152	,
0.862069	,
0.875275	,
0.87914	,
0.872054	,
0.867867	,
0.864968	,
0.858848	,
0.854983	,
0.85595	,
0.854661	,
0.858204	,
0.863036	,
0.865935	,
0.86368	,
0.864002	,
0.877852	,
0.893312	,
0.906518	,
0.906518	,
0.898788	,
0.889769	,
0.879784	,
0.879784	,
0.882361	,
0.895567	,
0.910061	,
0.919402	,
0.926166	,
0.927132	,
0.927776	,
0.92681	,
0.928098	,
0.927776	,
0.927132	,
0.921978	,
0.922945	,
0.919402	,
0.896855	,
0.88365	,
0.89138	,
0.898144	,
0.906518	,
0.903297	,
0.897177	,
0.903297	,
0.91296	,
0.921656	,
0.930997	,
0.937117	,
0.940338	,
0.945491	,
0.937761	,
0.938083	,
0.934218	,
0.93293	,
0.922623	,
0.909739	,
0.894601	,
0.893957	,
0.895889	,
0.890736	,
0.884294	,
0.889125	,
0.889447	,
0.889125	,
0.88687	,
0.896533	,
0.905552	,
0.911349	,
0.91296	,
0.918435	,
0.929065	,
0.921656	,
0.906518	,
0.909417	,
0.917147	,
0.922623	,
0.930031	,
0.930997	,
0.930997	,
0.934218	,
};

// FFTに与える窓のデータ ハニング関数
static const int16_t window_data[DATA_SIZE_SPO2] = {
2621.44	,
2639.595355	,
2694.017685	,
2784.57589	,
2911.05182	,
3073.140801	,
3270.45237	,
3502.511213	,
3768.758314	,
4068.552299	,
4401.170979	,
4765.813094	,
5161.600242	,
5587.578992	,
6042.723186	,
6525.936405	,
7036.054615	,
7571.848969	,
8132.028769	,
8715.24457	,
9320.091439	,
9945.112331	,
10588.80161	,
11249.60865	,
11925.94162	,
12616.17126	,
13318.63485	,
14031.64019	,
14753.46968	,
15482.38449	,
16216.6287	,
16954.43355	,
17694.0217	,
18433.61154	,
19171.42143	,
19905.67403	,
20634.60056	,
21356.44507	,
22069.46869	,
22771.95378	,
23462.20809	,
24138.56883	,
24799.4067	,
25443.12976	,
26068.18732	,
26673.07366	,
27256.33163	,
27816.5562	,
28352.39782	,
28862.56567	,
29345.8308	,
29801.02903	,
30227.06382	,
30622.90888	,
30987.61063	,
31320.29054	,
31620.14719	,
31886.45824	,
32118.58217	,
32315.9598	,
32478.11566	,
32604.65913	,
32695.28536	,
32749.77605	,
32767,
32749.91311	,
32695.55914	,
32605.06896	,
32478.66057	,
32316.63847	,
32119.39297	,
31887.39921	,
31621.21606	,
31321.48475	,
30988.9273	,
30624.34482	,
30228.61559	,
29802.69288	,
29347.60273	,
28864.44142	,
28354.37286	,
27818.62577	,
27258.49075	,
26675.31712	,
26070.50973	,
25445.52551	,
24801.87003	,
24141.09381	,
23464.78862	,
22774.58366	,
22072.14157	,
21359.15452	,
20637.34005	,
19908.43697	,
19174.20116	,
18436.40136	,
17696.81489	,
16957.22338	,
16219.40845	,
15485.14747	,
14756.20923	,
14034.3497	,
13321.30781	,
12618.80122	,
11928.52225	,
11252.13373	,
10591.26506	,
9947.508217	,
9322.413988	,
8717.488187	,
8134.188049	,
7573.918712	,
7038.029834	,
6527.812341	,
6044.495321	,
5589.243057	,
5163.152228	,
4767.249263	,
4402.487871	,
4069.746741	,
3769.82743	,
3503.452427	,
3271.263413	,
3073.819721	,
2911.596982	,
2784.98598	,
2694.291715	,
2639.732665	,
};

/************************************************************/
/* 変数定義													*/
/************************************************************/
double*	p4;
double*	f1;

static double	mx1_;
static double	mx2_;
static int	snpk1_;
static int	snpk2_;
static int		sp1_;

/*------------------------------------------------------------------------------*/

/********************************************************************/
/* 関数     : calculator_pulse_oximeter_red							*/
/* 関数名   : パルスオキシメーター演算[赤色]						*/
/* 引数     : なし													*/
/* 戻り値   : なし													*/
/* 変更履歴 : 2018.01.11 Axia Soft Design 和田	初版作成			*/
/********************************************************************/
/* 機能 :															*/
/* 																	*/
/********************************************************************/
/* 注意事項 :														*/
/* なし																*/
/********************************************************************/
// データ数はFFTライブラリに合わせて128固定
void calculator_pulse_oximeter_red(const signed long* pdata1)
{
	double tmp;
	int i;
	
	for (i=0; i<DATA_SIZE_SPO2; i++)
	{
		tmp = (double)pdata1[i];
		// -3〜3Vの24bit分解能AD値
		temp_dbl_buf2[i] = (double)(tmp * 3 / 32767);
	}
//	proc(test_data, DATA_SIZE_SPO2, &snpk1_, &mx1_);
	proc(temp_dbl_buf2, DATA_SIZE_SPO2, &snpk1_, &mx1_);
	if((0 > snpk1_) || (snpk1_ > 200)){
		snpk1_ = 0;
	}
}

/********************************************************************/
/* 関数     : calculator_pulse_oximeter_inf							*/
/* 関数名   : パルスオキシメーター演算[赤外]						*/
/* 引数     : なし													*/
/* 戻り値   : なし													*/
/* 変更履歴 : 2018.01.11 Axia Soft Design 和田	初版作成			*/
/********************************************************************/
/* 機能 :															*/
/* 																	*/
/********************************************************************/
/* 注意事項 :														*/
/* なし																*/
/********************************************************************/
// データ数はFFTライブラリに合わせて128固定
void calculator_pulse_oximeter_inf(const signed long* pdata1)
{
	double tmp;
	int i;
	
	for (i = 0; i<DATA_SIZE_SPO2; i++)
	{
		tmp = (double)pdata1[i];
		temp_dbl_buf2[i] = (double)(tmp * 3 / 32767);
	}
	proc(temp_dbl_buf2, DATA_SIZE_SPO2, &snpk2_, &mx2_);
	if((0 > snpk2_) || (snpk2_ > 200)){
		snpk2_ = 0xFF;
	}
	
	/*- SPO2 --------------------------------------------------------------*/
	cal_sp1( mx1_, mx2_, &sp1_ );
	if((0 > sp1_) || (sp1_ > 200)){
		sp1_ = 0xFF;
	}
}

/********************************************************************/
/* 関数     : proc													*/
/* 関数名   : 														*/
/* 引数     : なし													*/
/* 戻り値   : なし													*/
/* 変更履歴 : 2018.01.11 Axia Soft Design 和田	初版作成			*/
/********************************************************************/
/* 機能 :															*/
/* 																	*/
/********************************************************************/
/* 注意事項 :														*/
/* len = 128でないと動かない										*/
/********************************************************************/
static void	proc(const double *data1, int len, int* psnpk, double* pmk)
{
	int ii;
	
	double* ph11;
	int16_t* pfft_in;

	int16_t* pfft_out;

	double* a1;
	double* p2;
	double* ar2;
	double* ai2;
	double* p3;
	int16_t* peak1;
	
	const int loop = len * 2;
	const int start = 9;
	const int end   = 92 + start;
	const double coeff = 0.30172;
	
	int size;
	double max;
	
	/*- フィルタ処理 -----------------------------------------------------------------*/
	ph11 = &temp_dbl_buf0[0];
	bandpass(data1, ph11, len, 20, 2, 2);
	
	/*- fft --------------------------------------------------------------------*/
	pfft_in = &temp_int_buf0[0];
	for(ii=0;ii<len;++ii){
		pfft_in[ii] = (int16_t)(ph11[ii] * 32768.0f);
	}
	pfft_out = &temp_int_buf2[0];
    /* execute 128-point real FFT with windowing */
    R_rfft128_int16(pfft_in, pfft_out, window_data, temp_int_buf1);

	/*- 不要なデータをマスクする------------------------------------------------*/
	/*- パワーを求める----------------------------------------------------------*/
	a1 = &temp_dbl_buf0[0];
	p2 = &temp_dbl_buf1[0];
	for(ii=0;ii<loop;++ii){
		a1[ii] = pfft_out[ii] / 128.0;
	}
	// startまではall 0
	for(ii=0;ii<start;++ii){
		p2[ii] = 0;
	}
	for(ii=start;ii<end;++ii){
		p2[ii] = a1[2*ii]*a1[2*ii] + a1[2*ii+1]*a1[2*ii+1];
		p2[ii] = sqrt(p2[ii]);
	}
	for(ii=end;ii<loop;++ii){
		p2[ii] = 0;
	}
	
	/*- 逆FFT --------------------------------------------------------------*/
	ar2 = &temp_dbl_buf1[0];
	ai2 = &temp_dbl_buf2[0];
	size = loop/2;
	for(ii=0;ii<size;++ii){
		ar2[ii] = p2[ii];
		ai2[ii] = 0;
	}
	for(ii=0;ii<size;++ii){
		ar2[size+ii] = p2[size-ii];
		ai2[size+ii] = 0;
	}
	
	p3 = &temp_dbl_buf0[0];
	ifft(ar2, loop, p3);
	
	/*- 最大値との比を計算 --------------------------------------------------------------*/
	max = 0;
	for(ii=0;ii<len;++ii){
		if(max < p3[ii]){
			max = p3[ii];
		}
	}
	for(ii=0;ii<len;++ii){
		p3[ii] /= max;
	}
	
	/*- ピーク検出 --------------------------------------------------------------*/
	peak1 = &temp_int_buf0[0];
	p4 = &temp_dbl_buf1[0];
	f1 = &temp_dbl_buf2[0];
	peak_vallay( p3 , peak1 , len, 3 , 0.1 , 1 );
	peak_modify( p3 , peak1 , p4 , f1 , len , 1);
	
	/*- HR --------------------------------------------------------------*/
	*psnpk = 60 / (f1[0] * coeff);
	*pmk   = p4[0];
}

/*==============================================================================*/
/*	bandpass																	*/
/*==============================================================================*/
/**
	float input[]  …入力信号の格納されたバッファ。
	flaot output[] …フィルタ処理した値を書き出す出力信号のバッファ。
	int   size     …入力信号・出力信号のバッファのサイズ。
	float samplerate … サンプリング周波数
	float freq … カットオフ周波数
	float bw   … 帯域幅
**/
/*==============================================================================*/
static void bandpass(const double input[], double output[], int size, double samplerate, double freq, double bw)
{
	// フィルタ係数を計算する
	double omega = 2.0f * 3.14159265f *  freq/samplerate;
	double ctmp = log(2.0f) / 2.0 * bw * omega / sin(omega);
	double alpha = sin(omega) * sinh(ctmp);
 
	double a0 =  1.0f + alpha;
	double a1 = -2.0f * cos(omega);
	double a2 =  1.0f - alpha;
	double b0 =  alpha;
	double b1 =  0.0f;
	double b2 = -alpha;

	// フィルタ計算用のバッファ変数。
	double in1  = 0.0f;
	double in2  = 0.0f;
	double out1 = 0.0f;
	double out2 = 0.0f;
	int i;
	
	// フィルタを適用
	for(i = 0; i < size; i++)
	{
		// 入力信号にフィルタを適用し、出力信号として書き出す。
		output[i] = b0/a0 * input[i] + b1/a0 * in1  + b2/a0 * in2
		                             - a1/a0 * out1 - a2/a0 * out2;
 
		in2  = in1;       // 2つ前の入力信号を更新
		in1  = input[i];  // 1つ前の入力信号を更新
 
		out2 = out1;      // 2つ前の出力信号を更新
		out1 = output[i]; // 1つ前の出力信号を更新
	}
}

// 心拍数(赤色)
UB get_sinpak(void)
{
	return (UB)snpk1_;
}

// SPO2を取得
UB get_spo2(void)
{
	return (UB)sp1_;
}

/*==============================================================================*/
/* EOF */
